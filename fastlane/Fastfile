fastlane_require 'dotenv'

before_all do
  Dotenv.overload '.env'

  # bundle_install
end

desc "Update project dependencies"
private_lane :update_dependencies do |options|
  sh("git checkout " + options[:git_branch])
  git_pull
  yarn(
    command: "install",
    package_path: "#{ENV['PROJECT_DIR']}/package.json"
  )
end

desc "Upload build to installr"
private_lane :upload_installr do |options|
  puts options[:file]
  notes = options[:notes] || "Build from Fastlane"
  installr(
      api_token: ENV['INSTALLR_TOKEN'],
      ipa: options[:file],
      notes: notes,
      notify: "true",
      add: options[:testers]
    )
end

desc "Commit changes to repo"
private_lane :sync_git do |options|
  git_add(path: "#{ENV['PROJECT_DIR']}/*")
  git_commit(
    path: "#{ENV['PROJECT_DIR']}/*",
    message: options[:message],
    allow_nothing_to_commit: true
  )
  push_to_git_remote
end

lane :get_team_names do |options|
  require "spaceship"
  puts options
  client_tunes = Spaceship::Tunes.login(options[:id], options[:password])
  client = Spaceship::Portal.login(options[:id], options[:password])

  str_client_tunes = "" 
  client_tunes.teams.each do |team|
      UI.message "#{team['contentProvider']['name']} (#{team['contentProvider']['contentProviderId']})"
      str_client_tunes << "#{team['contentProvider']['name']} (#{team['contentProvider']['contentProviderId']})||"
  end

  str_dev_portal = "" 
  client.teams.each do |team|
      UI.message "#{team['name']} (#{team['teamId']})"
      str_dev_portal << "#{team['name']} (#{team['teamId']})||"
  end
end

platform :ios do
  ios_project_path = "#{ENV['PROJECT_DIR']}/ios"
  xcodeproj = "#{ios_project_path}/#{ENV['XCODEPROJ_NAME']}.xcodeproj"

  def ensure_temp_keychain
    delete_keychain(
      name: 'rnbuilder'
    ) if File.exist? File.expand_path("~/Library/Keychains/#{name}-db")
    create_keychain(
      name: 'rnbuilder',
      password: 'rnbuilder',
      unlock: true,
      timeout: 3600
    )
  end

  before_all do
    ensure_temp_keychain "rnbuilder"
  end

  desc 'Process build'
  private_lane :process_build do |options| 
    update_dependencies(
      git_branch: options[:branch],
    )
    cocoapods(
      podfile: "#{ios_project_path}/Podfile", 
      use_bundle_exec: true,
      try_repo_update_on_error: true,
    )
    targets = [ENV['CLIENT']]
    if ENV['SERVICE_EXTENSION_NAME']
      targets = targets.push(ENV['SERVICE_EXTENSION_NAME'])
    end
    
    update_project_team( # Set the right team on your project
      path: xcodeproj,
      teamid: ENV['APPLE_TEAM_ID'],
      targets: targets
    )
    update_project_provisioning(
      xcodeproj: xcodeproj,
      profile: options[:profile],
      target_filter: ENV['CLIENT'], # matches name or type of a target
      build_configuration: "Release",
    )
    if ENV['SERVICE_EXTENSION_NAME']
      update_project_provisioning(
        xcodeproj: xcodeproj,
        profile: options[:profile_service_extension],
        target_filter: ENV['SERVICE_EXTENSION_NAME'],
        build_configuration: "Release",
      )
    end
    build_app(
      workspace: "#{ios_project_path}/#{ENV['XCODEPROJ_NAME']}.xcworkspace",
      clean: true,
      scheme: options[:scheme],
      export_method: options[:export_method],
      output_name: options[:output_name],
      include_symbols: true,
      include_bitcode: true,
      skip_profile_detection: true,
      build_path: "#{ENV['PROJECT_DIR']}/fastlane/builds",
      output_directory: "#{ENV['PROJECT_DIR']}/fastlane/builds"
    )
    if options[:installr]
      file = Actions.lane_context[SharedValues::IPA_OUTPUT_PATH]
      upload_installr(
        file: file,
        notes: options[:scheme],
        testers: options[:testers]
      )
    end
  end

  desc "Prepare staging build"
  lane :staging do |options|
    app_id = ENV['APP_IDENTIFIER_STAGING'] || ENV['APP_IDENTIFIER'] + ".staging"
    app_name = ENV['APP_NAME_STAGING'] || ENV['APP_NAME']
    app_identifier = [app_id]
    if ENV['SERVICE_EXTENSION_NAME'] 
      app_identifier = app_identifier.push("#{app_id}.#{ENV['SERVICE_EXTENSION_NAME']}")
    end
    match(
      app_identifier: app_identifier,
      type: 'adhoc',
      username: ENV['APPLE_ID'],
      team_id: ENV['APPLE_TEAM_ID'],
      git_url: ENV['MATCH_GIT_URL'],
      git_branch: ENV['CLIENT'],
      force_for_new_devices: true,
      readonly: is_ci,
      keychain_name: 'rnbuilder',
      keychain_password: 'rnbuilder',
    )
    process_build(
      branch: options[:branch],
      installr: options[:installr],
      scheme: "#{ENV['CLIENT']} staging",
      output_name: app_name,
      export_method: "ad-hoc",
      profile: ENV["sigh_#{app_id}_adhoc_profile-path"],
      profile_service_extension: ENV["sigh_#{app_id}.#{ENV['SERVICE_EXTENSION_NAME']}_adhoc_profile-path"]
    )
    sync_git(
      message: "chore: staging build"
    )
  end

  desc "Prepare adhoc build"
  lane :adhoc do |options|
    app_identifier = [ENV['APP_IDENTIFIER']]
    if ENV['SERVICE_EXTENSION_NAME']
      app_identifier = app_identifier.push("#{ENV['APP_IDENTIFIER']}.#{ENV['SERVICE_EXTENSION_NAME']}")
    end
    match(
      app_identifier: app_identifier,
      type: 'adhoc',
      username: ENV['APPLE_ID'],
      team_id: ENV['APPLE_TEAM_ID'],
      git_url: ENV['MATCH_GIT_URL'],
      git_branch: ENV['CLIENT'],
      force_for_new_devices: true,
      readonly: is_ci,
      keychain_name: 'rnbuilder',
      keychain_password: 'rnbuilder',
    )
    process_build(
      branch: options[:branch],
      installr: options[:installr],
      scheme: "#{ENV['CLIENT']} prod",
      output_name: ENV['APP_NAME'],
      export_method: "ad-hoc",
      profile: ENV["sigh_#{ENV['APP_IDENTIFIER']}_adhoc_profile-path"],
      profile_service_extension: ENV["sigh_#{ENV['APP_IDENTIFIER']}.#{ENV['SERVICE_EXTENSION_NAME']}_adhoc_profile-path"]
    )
    sync_git(
      message: "chore: adhoc build"
    )
  end

  desc "Push a new beta build to TestFlight"
  lane :prod do |options|
    build_number = options[:build_number]
    puts options
    if build_number.nil?
      UI.message "Don't specify build number. Getting latest build number from testflight"
      latest_build = 0
      begin
        latest_build = latest_testflight_build_number(
          username: ENV['APPLE_ID'],
          # team_id: "119976767", #ENV['APPLE_TEAM_ID'],
          app_identifier: ENV['APP_IDENTIFIER']
        )
      rescue => ex
        UI.error "latest_testflight_build_number got error #{ex}. Trying to get build number from plist"
        latest_build = get_build_number_from_plist(
          xcodeproj: xcodeproj,
          target: ENV['CLIENT'],
        ).to_i
        UI.message "Build number in plist: #{latest_build}"
      end
      build_number = latest_build + 1
    end
    if ENV['SERVICE_EXTENSION_NAME']
      increment_version_number_in_plist(
        xcodeproj: xcodeproj,
        version_number: options[:version_number], # Set a specific version number
        target: ENV['SERVICE_EXTENSION_NAME']
      )
      increment_build_number_in_plist(
        xcodeproj: xcodeproj,
        build_number: build_number.to_s,
        target: ENV['SERVICE_EXTENSION_NAME']
      )
    end
    app_identifier = [ENV['APP_IDENTIFIER']]
    if ENV['SERVICE_EXTENSION_NAME']
      app_identifier = app_identifier.push("#{ENV['APP_IDENTIFIER']}.#{ENV['SERVICE_EXTENSION_NAME']}")
    end
    match(
      app_identifier: app_identifier,
      type: 'appstore',
      username: ENV['APPLE_ID'],
      team_id: ENV['APPLE_TEAM_ID'],
      git_url: ENV['MATCH_GIT_URL'],
      git_branch: ENV['CLIENT'],
      readonly: is_ci,
      keychain_name: 'rnbuilder',
      keychain_password: 'rnbuilder',
    )
    process_build(
      branch: options[:branch],
      installr: options[:installr],
      scheme: "#{ENV['CLIENT']} prod",
      output_name: ENV['APP_NAME'],
      export_method: "app-store",
      profile: ENV["sigh_#{ENV['APP_IDENTIFIER']}_appstore_profile-path"],
      profile_service_extension: ENV["sigh_#{ENV['APP_IDENTIFIER']}.#{ENV['SERVICE_EXTENSION_NAME']}_appstore_profile-path"]
    )
    upload_to_testflight(
      username: ENV['APPLE_ID'],
      app_identifier: ENV['APP_IDENTIFIER'],
      skip_waiting_for_build_processing: true,
      team_id: ENV['ITC_TEAM_ID']
    )
    sync_git(
      message: "chore: production build"
    )
  end
end

platform :android do
  desc "Process android build"
  private_lane :process_android_build do |options|
    update_dependencies(
      git_branch: options[:branch]
    )
    gradle(
      task: "clean",
      project_dir: "#{ENV['PROJECT_DIR']}/android",
    )
    gradle(
      task: options[:task] || 'assemble',
      flavor: options[:flavor],
      build_type: options[:build_type],
      project_dir: "#{ENV['PROJECT_DIR']}/android",
      properties: options[:properties]
    )
    if options[:installr]
      file = Actions.lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]
      upload_installr(
        file: file,
        notes: options[:notes] || "Fastlane build"
      )
    end
  end

  desc "Process Staging build"
  lane :staging do |options|
    flavor = ENV["FLAVOR_STAGING"] || ENV["FLAVOR"]
    build_type = ENV["BUILD_TYPE_STAGING"] || ENV["BUILD_TYPE"]
    process_android_build(
      branch: options[:branch],
      installr: options[:installr],
      flavor: flavor,
      build_type: build_type
    )
  end

  desc "Process Adhoc build"
  lane :adhoc do
    process_android_build(
      branch: options[:branch],
      installr: options[:installr],
      flavor: ENV["FLAVOR"],
      build_type: ENV["BUILD_TYPE"],
    )
  end

  desc "Process Prod build"
  lane :prod do |options|
    process_android_build(
      branch: options[:branch],
      installr: options[:installr],
      task: 'bundle',
      flavor: ENV["FLAVOR"],
      build_type: ENV["BUILD_TYPE"]
    )
    upload_to_play_store(
      track: 'internal',
      skip_upload_apk: true,
      skip_upload_metadata: true,
      skip_upload_changelogs: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      package_name: ENV["APP_IDENTIFIER"],
      json_key: ENV["JSON_KEY_FILE"]
    )
  end

  desc "Update Store Listing"
  lane :store_listing do |options|
    metadata = options[:metadata] || false
    changelogs = options[:changelogs] || false
    images = options[:images] || false
    screenshots = options[:screenshots] || false
    UI.message "Update Store Listing with metadata:#{metadata} changelogs:#{changelogs} images:#{images} screenshots:#{screenshots}"
    upload_to_play_store(
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_metadata: !metadata,
      skip_upload_changelogs: !changelogs,
      skip_upload_images: !images,
      skip_upload_screenshots: !screenshots,
      package_name: ENV["APP_IDENTIFIER"],
      json_key: ENV["JSON_KEY_FILE"]
    )
  end
end