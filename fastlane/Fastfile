require_relative "./version.rb"
require 'json'

desc "Send discord message"
lane :send_message do |options| 
  if ENV['DISCORD_WEBHOOK_URL']
    discord_notification(
      webhook_url: ENV['DISCORD_WEBHOOK_URL'],
      mention_users: options[:mention_users],
      thumbnail_url: ENV['DISCORD_THUMBNAIL_URL'],
      content: options[:content],    
      title: options[:title],
      description: options[:description],
      color: options[:color],
    )
  end
end

desc "Commit changes to repo"
private_lane :sync_git do |options|
  git_add(path: "#{ENV['PROJECT_DIR']}/*")
  git_commit(
    path: "#{ENV['PROJECT_DIR']}/*",
    message: options[:message],
    allow_nothing_to_commit: true
  )
  git_pull(rebase: true)
  push_to_git_remote
end

platform :ios do
  ios_project_path = "#{ENV['PROJECT_DIR']}/ios"
  xcodeproj = "#{ios_project_path}/#{ENV['XCODEPROJ_NAME']}.xcodeproj"

  def get_ios_version(increment = "patch")
    begin 
      latest_testflight_build_number(
          username: ENV['APPLE_ID'],
          team_id: ENV['ITC_TEAM_ID'],
          app_identifier: ENV['APP_IDENTIFIER'],
      )
      app_store_build_number(
        username: ENV['APPLE_ID'],
        team_id: ENV['ITC_TEAM_ID'],
        app_identifier: ENV['APP_IDENTIFIER'],
      )
    rescue => exception
      puts exception
    end
    tf_version = Actions.lane_context[SharedValues::LATEST_TESTFLIGHT_VERSION] || "1.0.0"
    store_version = Actions.lane_context[SharedValues::LATEST_VERSION] || "1.0.0"
    puts "TF Version #{tf_version}"
    puts "Store Version #{store_version}"
    next_v = next_version(store_version, increment)
    if Gem::Version.new(tf_version) >= Gem::Version.new(next_v)
        tf_build_number = Actions.lane_context[SharedValues::LATEST_TESTFLIGHT_BUILD_NUMBER] || 1
        store_build_number = Actions.lane_context[SharedValues::LATEST_BUILD_NUMBER] || 1
        puts "TF build number #{tf_build_number}"
        puts "Store build number #{store_build_number}"
        if tf_build_number == store_build_number 
          next_v = next_version(tf_version, 'patch')
        else
          next_v = tf_version
        end
    end
    puts "Next Version #{next_v}"
    return next_v
  end

  def ensure_temp_keychain(name)
    delete_keychain(
      name: name
    ) if File.exist? File.expand_path("~/Library/Keychains/#{name}-db")
    create_keychain(
      name: name,
      password: 'rnbuilder',
      unlock: true,
      timeout: 3600
    )
  end

  before_all do
    ensure_temp_keychain "rnbuilder"
  end

  desc 'Process build'
  private_lane :process_build do |options|
    puts "Process build with options: #{options}"

    update_project_provisioning(
      xcodeproj: xcodeproj,
      profile: options[:profile],
      build_configuration: "Release",
    )
    if ENV['SERVICE_EXTENSION_NAME']
      update_project_provisioning(
        xcodeproj: xcodeproj,
        profile: options[:profile_service_extension],
        target_filter: ENV['SERVICE_EXTENSION_NAME'],
        build_configuration: "Release",
      )
    end
    build_app(
      workspace: "#{ios_project_path}/#{ENV['XCODEPROJ_NAME']}.xcworkspace",
      clean: true,
      scheme: options[:scheme],
      export_method: options[:export_method],
      output_name: options[:output_name],
      include_symbols: true,
      include_bitcode: ENV['INCLUDE_BITCODE'] == 'true',
      skip_profile_detection: true,
      build_path: "#{ENV['PROJECT_DIR']}/fastlane/builds",
      output_directory: "#{ENV['PROJECT_DIR']}/fastlane/builds"
    )
  end

  desc "Process build"
  lane :build do |options|
    puts "Start building app for env #{options[:env]}"
    send_message(
      title: "#{ENV['CLIENT']} ios - #{options[:env]}",
      description: "Start building...",
      color: "#282C34",
    )
    app_id = ENV['APP_IDENTIFIER']
    app_name = ENV['APP_NAME']
    app_identifier = [app_id]
    export_method = options[:distribute] == 'store' ? 'app-store' : 'ad-hoc'
    match_type = options[:distribute] == 'store' ? 'appstore' : 'adhoc'
    if ENV['SERVICE_EXTENSION_NAME']
      app_identifier = app_identifier.push("#{app_id}.#{ENV['SERVICE_EXTENSION_NAME']}")
    end
    match(
      app_identifier: app_identifier,
      type: match_type,
      username: ENV['APPLE_ID'],
      team_id: ENV['APPLE_TEAM_ID'],
      git_url: ENV['MATCH_GIT_URL'],
      git_branch: ENV['CLIENT'],
      force_for_new_devices: true,
      readonly: ENV['MATCH_READONLY'] || is_ci,
      keychain_name: 'rnbuilder',
      keychain_password: 'rnbuilder',
    )
    version = options[:distribute] == 'store' ? get_ios_version(options[:version]) : nil
    version = write_json_version(options[:json_file], options[:client], 'ios', version)
    sync_git(
      message: "bump version #{options[:client]} - ios"
    )
    process_build(
      testers: options[:testers],
      scheme: ENV['XCODEPROJ_SCHEME'],
      output_name: app_name,
      export_method: export_method,
      profile: ENV["sigh_#{app_id}_#{match_type}_profile-path"],
      profile_service_extension: ENV["sigh_#{app_id}.#{ENV['SERVICE_EXTENSION_NAME']}_#{match_type}_profile-path"]
    )
    file = Actions.lane_context[SharedValues::IPA_OUTPUT_PATH]
    if options[:installr]
      upload_installr(
        file: file,
        notes: options[:scheme],
        testers: options[:testers]
      )
    end
    if options[:firebase]
      upload_firebase(
        app: ENV['FIREBASE_IOS_APP'],
        service_credentials_file: ENV['FIREBASE_SERVICE_ACCOUNT_FILE'],
        file: file,
        notes: options[:notes] || "Fastlane build",
        testers: options[:testers],
        groups: options[:groups],
      )
    end
    if options[:distribute] == 'store'
      upload_to_app_store(
        username: ENV['APPLE_ID'],
        app_identifier: ENV['APP_IDENTIFIER'],
        team_id: ENV['ITC_TEAM_ID'],
        app_version: version,
        release_notes: {
          'default' => 'Bug fixes and performance improvement',
          'en-US' => 'Bug fixes and performance improvement'
        },
        force: true,
        submit_for_review: true,
        automatic_release: true,
        skip_screenshots: true,
        skip_metadata: false,
        run_precheck_before_submit: false,
        submission_information: {
          add_id_info_uses_idfa: false,
          add_id_info_serves_ads: false,
          add_id_info_tracks_install: false,
          add_id_info_tracks_action: false,
          add_id_info_limits_tracking: false,
        }
      )
    end
    sync_git(
      message: "build #{ENV['CLIENT']} ios - success ✅"
    )
    send_message(
      title: "#{ENV['CLIENT']} ios - #{options[:env]}",
      description: "Success ✅",
      color: '#00C40F',
      mention_users: ENV['DISCORD_MENTION_USERS'],
    )
  end

  error do |lane, exception|
    sync_git(
      message: "build #{ENV['CLIENT']} ios - failed ❌"
    )
    send_message(
      title: "#{ENV['CLIENT']} ios - #{options[:env]}",
      description: "Failure ❌",
      color: '#E70000',
      mention_users: ENV['DISCORD_MENTION_USERS'],
    )
  end
end

platform :android do
  def get_android_version(increment = "patch")
    begin
      prod_version = google_play_track_release_names(
          json_key: ENV["JSON_KEY_FILE"],
          package_name: ENV["APP_IDENTIFIER_ANDROID"] || ENV["APP_IDENTIFIER"],
          track: 'production'
      )
      internal_version = google_play_track_release_names(
          json_key: ENV["JSON_KEY_FILE"],
          package_name: ENV["APP_IDENTIFIER_ANDROID"] || ENV["APP_IDENTIFIER"],
          track: 'internal'
      )
      puts prod_version
      puts internal_version
      new_version = next_version(prod_version.first, increment)
      if Gem::Version.new(internal_version.first.to_s) > Gem::Version.new(new_version.to_s)
          new_version = internal_version.first
      end
      return new_version
    rescue => exception
      puts exception
    end
    new_version = prompt(text: "Can't get latest version from store. Please specify next version (e.g: 2.2.3)")
    return new_version
  end

  desc "Process android build"
  private_lane :process_android_build do |options|
    gradle(
      task: options[:task],
      flavor: options[:flavor],
      build_type: options[:build_type],
      project_dir: "#{ENV['PROJECT_DIR']}/android",
      properties: options[:properties]
    )
  end

  desc "Process build"
  lane :build do |options|
    send_message(
      title: "#{ENV['CLIENT']} android - #{options[:env]}",
      description: "Start building...",
      color: "#282C34"
    )
    flavor = ENV["FLAVOR"]
    build_type = ENV["BUILD_TYPE"]
    version = options[:distribute] == 'store' ? get_android_version(options[:version]) : nil
    write_json_version(options[:json_file], options[:client], 'android', version)
    sync_git(
      message: "bump version #{options[:client]} - android"
    )
    process_android_build(
      branch: options[:branch],
      testers: options[:testers],
      flavor: flavor,
      build_type: build_type,
      task: options[:distribute] == 'store' ? 'bundle' : 'assemble',
    )
    file = Actions.lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH]
    if options[:installr]
      upload_installr(
        file: file,
        notes: options[:notes] || "Fastlane build",
        testers: options[:testers]
      )
    end
    if options[:firebase]
      upload_firebase(
        app: ENV['FIREBASE_ANDROID_APP'],
        service_credentials_file: ENV['FIREBASE_SERVICE_ACCOUNT_FILE'],
        file: file,
        notes: options[:notes] || "Fastlane build",
        testers: options[:testers],
        groups: options[:groups],
      )
    end
    if options[:distribute] == 'store'
      upload_to_play_store(
        track: 'production',
        release_status: ENV['RELEASE_STATUS'] || 'completed',
        skip_upload_changelogs: false,
        skip_upload_apk: true,
        skip_upload_metadata: true,
        skip_upload_images: true,
        skip_upload_screenshots: true,
        package_name: ENV["APP_IDENTIFIER_ANDROID"] || ENV["APP_IDENTIFIER"],
        json_key: ENV["JSON_KEY_FILE"]
      )
    end
    sync_git(
      message: "Build #{ENV['CLIENT']} - success ✅"
    )
    send_message(
      title: "#{ENV['CLIENT']} android - #{options[:env]}",
      description: "Success ✅",
      color: '#00C40F',
      mention_users: ENV['DISCORD_MENTION_USERS'],
    )
  end

  desc "Update Store Listing"
  lane :store_listing do |options|
    metadata = options[:metadata] || false
    changelogs = options[:changelogs] || false
    images = options[:images] || false
    screenshots = options[:screenshots] || false
    UI.message "Update Store Listing with metadata:#{metadata} changelogs:#{changelogs} images:#{images} screenshots:#{screenshots}"
    upload_to_play_store(
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_metadata: !metadata,
      skip_upload_changelogs: !changelogs,
      skip_upload_images: !images,
      skip_upload_screenshots: !screenshots,
      package_name: ENV["APP_IDENTIFIER"],
      json_key: ENV["JSON_KEY_FILE"]
    )
  end

  error do |lane, exception|
    sync_git(
      message: "build #{ENV['CLIENT']} android - failed ❌"
    )
    send_message(
      title: "#{ENV['CLIENT']} android - #{options[:env]}",
      description: "Failure ❌",
      color: '#E70000',
      mention_users: ENV['DISCORD_MENTION_USERS'],
    )
  end
end

desc "Create Onesignal certificate"
lane :sync_onesignal do |options|
  puts ENV['APP_IDENTIFIER']
  cert_path = "#{ENV['PROJECT_DIR']}/fastlane/certs"
  get_push_certificate(
    force: true,
    app_identifier: ENV['APP_IDENTIFIER'],
    username: ENV['APPLE_ID'],
    team_id: ENV['APPLE_TEAM_ID'],
    output_path: cert_path,
  )
  onesignal(
    app_id: ENV['ONE_SIGNAL_APP_ID'],
    auth_token: ENV['ONE_SIGNAL_AUTH_TOKEN'],
    apns_p12: "#{cert_path}/production_#{ENV['APP_IDENTIFIER']}_ios.p12",
  )
end

tester_udids_file = "tester_udids.txt"

desc "Sync devices"
lane :sync_udids do
  firebase_app_distribution_get_udids(
    app: ENV['FIREBASE_IOS_APP'],
    output_file: tester_udids_file,
    service_credentials_file: ENV['FIREBASE_SERVICE_ACCOUNT_FILE'],
  )
  register_devices(
    devices_file: tester_udids_file,
    username: ENV['APPLE_ID'],
    team_id: ENV['APPLE_TEAM_ID'],
  )
  sync_git(
    message: 'registered tester devices'
  )
end

desc "Upload build to firebase"
lane :upload_firebase do |options|
  puts Dir.pwd
  puts options
  notes = options[:notes] || "Build from Fastlane"
  firebase_app_distribution(
    app: options[:app],
    ipa_path: options[:file],
    android_artifact_type: "APK",
    android_artifact_path: options[:file],
    service_credentials_file: options[:service_credentials_file],
    testers: options[:testers],
    groups: options[:groups],
    release_notes: notes,
    debug: true,
  )
end

def inviteTesters(appId, token, testers)
  require 'net/http'
  require 'uri'

  puts "appId: #{appId}, token: #{token}, testers: #{testers}"
  uri = URI.parse("https://www.installrapp.com/apps/#{appId}/builds/latest/team.json")
  res = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    req = Net::HTTP::Post.new(uri)
    req['X-InstallrAppToken'] = token
    req.set_form_data({
      "notify" => testers
    }, ";")
    http.request(req)
  end
  puts res.body
  case res
  when Net::HTTPSuccess, Net::HTTPRedirection
    UI.success("Invite testers successfully")
  else
    res.error!
  end
end

desc "Upload build to installr"
lane :upload_installr do |options|
  notes = options[:notes] || "Build from Fastlane"
  installr(
    api_token: ENV['INSTALLR_TOKEN'],
    ipa: options[:file],
    notes: notes,
    notify: "true",
  )
  buildInfo = Actions.lane_context[SharedValues::INSTALLR_BUILD_INFORMATION]
  id = buildInfo["appData"]["id"]
  # id = 37106
  UI.success("Invite testers for app #{id}")
  inviteTesters(
    id,
    ENV['INSTALLR_TOKEN'],
    options[:testers]
  )
end

lane :get_team_names do |options|
  require "spaceship"
  puts options
  client_tunes = Spaceship::Tunes.login(options[:id], options[:password])
  client = Spaceship::Portal.login(options[:id], options[:password])

  str_client_tunes = "" 
  client_tunes.teams.each do |team|
      UI.message "#{team['contentProvider']['name']} (#{team['contentProvider']['contentProviderId']})"
      str_client_tunes << "#{team['contentProvider']['name']} (#{team['contentProvider']['contentProviderId']})||"
  end

  str_dev_portal = "" 
  client.teams.each do |team|
      UI.message "#{team['name']} (#{team['teamId']})"
      str_dev_portal << "#{team['name']} (#{team['teamId']})||"
  end
end
